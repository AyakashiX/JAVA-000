学习笔记

## 创建Java线程的方式?

一共有两种，oracle官网文档中有说明，一种是继承Thread类的类，另一种是实现了Runnable接口的类，都要重写run()方法，但重写的run方法不同。

## 一般推荐使用实现Runnable接口来创建线程，而不推荐使用继承Thread的方式，原因如下。

### 实现Runnable接口好在哪里？ 继承Thread类是不推荐的，因为它有以下的一些缺点：

\1. 从代码架构角度：具体的任务（run方法）应该和“创建和运行线程的机制（Thread类）”解耦， 用runnable对象可以实现解耦。 

\2. 使用继承Thread的方式的话，那么每次想新建一个任务，只能新建一个独立的线程，而这样做 的损耗会比较大（比如重头开始创建一个线程、执行完毕以后再销毁等。如果线程的实际工作内 容，也就是run()函数里只是简单的打印一行文字的话，那么可能线程的实际工作内容还不如损 耗来的大）。如果使用Runnable和线程池，就可以大大减小这样的损耗。 

\3. 继承Thread类以后，由于Java语言不支持双继承，这样就无法再继承其他的类，限制了可扩展 性。 通常我们优先选择方法1。



### 有多少种实现线程的方法？ 答题思路，以下5点： 

\1. 从不同的角度看，会有不同的答案。 

\2. 典型答案是两种，分别是实现Runnable接口和继承Thread类，然后具体展开说；

\3. 但是，我们看原理，其实Thread类实现了Runnable接口，并且看Thread类的run方法，会发现 其实那两种本质都是一样的，run方法的代码如下：

```
@Override
public void run() {
    if (target != null) {
    target.run();
    }
}
```

 4.方法一和方法二，也就是“继承Thread类然后重写run()”和“实现Runnable接口并传入Thread类”在实 现多线程的本质上，并没有区别，都是最终调用了start()方法来新建线程。这两个方法的最主要区别 在于run()方法的内容来源： 方法一：最终调用target.run(); 方法二：run()整个都被重写

 \5. 然后具体展开说其他方式； 还有其他的实现线程的方法，例如线程池等，它们也能新建线程，但是细看源码，从没有逃出过 本质，也就是实现Runnable接口和继承Thread类。

 \6. 结论:我们只能通过新建Thread类这一种方式来创建线程，但是类里面的run方法有两种方式来实 现，第一种是重写run方法，第二种实现Runnable接口的run方法，然后再把该runnable实例传 给Thread类。除此之外，从表面上看线程池、定时器等工具类也可以创建线程，但是它们的本 质都逃不出刚才所说的范围。 以上这种描述比直接回答一种、两种、多种都更准确。



### 错误观点

其实创建线程的方式有很多种，但是本质上就是一种构建Thread类，最后也都是实现了Runnable接口的。

不管是线程池，Lambda表达式，还是匿名内部类，还是定时器，创建线程的本质是一样的，都是构建Thread类，只是形式不同。所以这些并不属于新的创建线程的机制。





面试题

有多少种实现线程的方法?



## 线程的启动方式

### start()和run()

#### start()方法的含义

启动新线程，但调用start()方法的顺序并不能决定线程实际启动的顺序。而且执行start()方法会创建2个线程，一个是main线程，一个是新的子线程比如Thread-0。

### start()方法的执行流程?

★start()方法不能重复执行，为什么?

1. 启动新线程前会检查线程状态，如果线程状态不为0，则抛出IllegalThreadStateException，jdk源码中的线程初始状态就是0，threadState=0，因为线程已经启动过一次了，这个状态值就不会是0了，所以会抛异常。
2. 然后加入线程组，
3. 最后调用start0()的native方法

且start()方法是被synchronized关键字修饰的，所以它是线程安全的。

### run()方法

run()方法在main下启动就相当于一个普通方法，会启动当前main线程，并不会去启动新的子线程，而真正要启动一个子线程，就需要使用start()方法。



## 停止线程的正确方法

**使用interrupt()方法来中断线程的操作**，但是使用interrupt()方法是用一个线程来通知另一个线程暂停，而不是强制线程暂停。Java中没有强制暂停线程，因为中断线程无法保证一定可以中断线程，最终的决定权还是在要被中断的线程本身上。

> **Java中停止线程的原则是什么？**
>
> **在Java中，最好的停止线程的方式是使用中断interrupt，但是这仅仅是会通知到被终止的线程“你该 停止运行了”，被终止的线程自身拥有决定权（决定是否、以及何时停止），这依赖于请求停止方和 被停止方都遵守一种约定好的编码规范。** 任务和线程的启动很容易。在大多数时候,我们都会让它们运行直到结束,或者让它们自行停止。然而, 有时候我们希望提前结束任务或线程,或许是因为用户取消了操作,或者服务需要被快速关闭，或者是 运行超时或出错了。 要使任务和线程能安全、快速、可靠地停止下来,并不是一件容易的事。**Java没有提供任何机制来安 全地终止线程。但它提供了中断( Interruption),这是一种协作机制，**能够使一个线程终止另一个线程 的当前工作。 这种协作式的方法是必要的,我们很少希望某个任务、线程或服务立即停止,因为这种立即停止会使共 享的数据结构处于不一致的状态。相反,在编写任务和服务时可以使用一种协作的方式：**当需要停止时, 它们首先会清除当前正在执行的工作，然后再结束。这提供了更好的灵活性,因为任务本身的代码比发 出取消请求的代码更清楚如何执行清除工作。** 生命周期结束(End-of-Lifecycle)的问题会使任务、服务以及程序的设计和实现等过程变得复杂,而这 个在程序设计中非常重要的要素却经常被忽略。一个在行为良好的软件与勉强运的软件之间的最主 要区别就是,行为良好的软件能很完善地处理失败、关闭和取消等过程。 本章将给出各种实现取消和中断的机制,以及如何编写任务和服务，使它们能对取消请求做出响应。



### 一般线程会在什么情况下停止?

- 当线程执行完毕
- 线程出现异常

当线程停止后，所占用的资源会被JVM所回收。



### 如何使用interrupt()方法

interrupt没法停止不是自己写的线程方法，因为如果线程run()方法没有标记被打断方法时，就无法停止线程。

所以正确的方式是:

> 使用当前线程的`thread.interrupt()`方法，并在run()方法中标明`!Thread.currentThread().isInterrupted()`

### 在线程阻塞的情况下如何停止线程

需要捕获run()方法中的阻塞代码，捕获到异常，并加入判断是否是当前线程被打断的标记。然后捕获InterruptedExceotion，这样在阻塞状态的线程就能被中断了。



如果在线程方法中有迭代方法，每次迭代时都有sleep()方法，那么遇到这种代码的时候就不需要在条件判断中加入是否被打断的方法`!Thread.currentThread().isInterrupted()`，在使用thread.interrupted()的时候自动会检测到。



### 处理中断的最好方法是什么(传递中断)？

> **优先选择在方法上抛出异常。** 
>
> 用throws InterruptedException 标记你的方法，不采用try 语句块捕获异常，以便于该异常可以传递 到顶层，让run方法可以捕获这一异常，例如： 由于run方法内无法抛出checked Exception（只能用try catch），顶层方法必须处理该异常，避免了 漏掉或者被吞掉的情况，增强了代码的健壮性。



### 不想或无法传递异常: 恢复中断

> **如果不能抛出中断，要怎么做？**
>
> 如果不想或无法传递InterruptedException（例如用run方法的时候，就不让该方法throws InterruptedException），那么应该选择在catch 子句中调用Thread.currentThread().interrupt() 来恢 复设置中断状态，以便于在后续的执行依然能够检查到刚才发生了中断。 代码演示详见视频，在这里，线程在sleep期间被中断，并且由catch捕获到该中断，并重新设置了中 断状态，以便于可以在下一个循环的时候检测到中断状态，正常退出。